#+title: CL-RRT
#+author: Masataro Asai
#+email: guicho2.71828@gmail.com
#+LINK: hs http://www.lispworks.com/reference/HyperSpec//%s

* CL-RRT - Common Lisp implementation of RRT (Rapidily exploring Random Tree)

[[https://raw.github.com/guicho271828/cl-rrt/master/test.png]]


RRT is a fast probabilistic multidimentional path-plannning algorithm
introduced by S.M.LaValle [fn:paper]. It now has a widespread use in robotics
and now able to handle the real time systems such as automatic car
driving AI. Also, it has various extentions and optimization methods
such as:

+ MP-RRT
+ RR-belief-tree
+ RRG
+ RRT*
+ St-RRT

The above image is a test result of a motion planner from the
start(red) to the end (blue). The path is avoiding the collision to
the randomly generated obstacles. The source is in =t/= .

[fn:paper] S.M. LaValle and J.J. Kuffner. Randomized kinodynamic
planning. /The International Journal of Robotics Research/, Vol. 20,
No. 5, pp. 378â€“400, 2001.

** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)
+ Clozure Common Lisp Version 1.9-r15757 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ ANAPHORA  ::
    
** Installation

+ First grab the code with =git clone git@github.com:guicho271828/cl-rrt.git=
+ Put it in local-project folder
+ open slime REPL
+ =(ql:quickload :cl-rrt)= and the library will be installed along with all
  the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)
+ Univ. Tokyo -> Grad. school of Tokyo University

* Concepts and API

C-space (configuration space) is a multidimentional space which
represents the state of a robot. For instance, since a human arm has 6
degree of freedom, the C-space also has at least 6
dimension. Additionally, the C-space is allowed to have the
differencial factor of each coordinate value. Therefore the C-space
might have at most 18 degree of freedom for the human arm because each
coordinate has its velocity and the accelaration.
For further explanation, read the Lavalle's paper.

Now, let /V/ as a type variable. We use this V to store the C-space
coordinate.

+ /V/ :: a vector class which represents a point in C-space.
           (configuration-space-distance V V) should return a number.
+ (node /V/) :: an rrt-tree-node instance whose /content/ slot is V.
                holonomic and non-holonomic parameters like velocity
                and acceralation should be stored in V.

I use these expression above as a type specifier in the following
description and specification.

** Core Interfaces
*** Standard Class: =rrt-tree-mixin= 				      :class:
The interface mixin class of random tree. User do not create an
instance of it, but rather inherit it. It has three slots and
accessors with the same names:

+ root :: the root node of the tree. of type rrt-tree-node.
+ finish-node :: a slot which contains the last node of the computed
                 path.  It is bound to nil, it means the previous
                 search has failed to find a path which satisfies the
                 goal condition.

*** Standard Class: =rrt-tree-node= 				      :class:

Node class of Random Tree. 

+ parent :: Parent node. 
+ children :: a list of child nodes.
+ content :: Stores C-space point data which should support a method
  [[cofiguration-space-distance]]. All holonomic and non-holonomic values
  such as position, velocity and accelaration should be stored in
  the instance in /content/.

*** Standard Generic Function: =configuration-space-distance= 	   :function:
#+BEGIN_SRC lisp
(configuration-space-distance point1 point2)
#+END_SRC

This generic function should provide a method to measure the distance
between two points in C-space (configuration space). Users should
implement the desired method on its own.

*** Standard Generic Function: =nearest-node=					   :function:
#+BEGIN_SRC lisp
(nearest-node target tree)
#+END_SRC

This generic function should implement a method
which finds the nearest node in a /tree/ to the /target/.
/target/ is an instance of point class.

*** Function: =rrt-search=					   :function:

#+BEGIN_SRC lisp
(rrt-search random-generator new-v-generator
            edge-prohibited-p finish-p
            &key start-v tree (tree-class 'rrt-tree-tree) (max-nodes 15)
            (max-iteration 30) run-on-node)
;; --> tree, num-nodes, iteration
#+END_SRC

RRT-search function.

+ random-generator :: (no args) -> /V/ random
+ new-v-generator ::  /V/ nearest, /V/ random -> /V/ new
+ edge-prohibited-p :: /V/ nearest, /V/ new -> /Bool/ result
+ finish-p :: /V/ new -> /Bool/ result

+ start-v :: /V/ -- A starting point of RRT searching in a C-space. It
             will be stored in the root node of the /tree/ if no
             /tree/ is specified in the *&key* arguments. 
+ tree :: A tree to be used as a prototype of the search.  It is
          going to be destructively modified in the search.  If not
          specified, it internally creates an instance of
          /tree-class/.
+ tree-class :: a /Class specifier/.
+ max-nodes :: a /Fixnum/ which specify the maximum number of nodes
               in the tree. When the total number of nodes reaches
               this limit, it finish the search iteration without
               setting the /finish-node/ of /tree/.
+ max-iteration :: a /Fixnum/ which specify the maximum number of
                   iteration in /rrt-search/. When the total number
                   of iteration reaches this limit, it finish the
                   search iteration without setting the
                   /finish-node/ of /tree/.
+ run-on-node :: /V/ nearest, /V/ new -> t
		 -- a function called in the last of each iteration.

/rrt-search/ returns the result tree as its primary value.  The
secondaly value is the total number of the nodes, and third value is
the number of iteration done in the search. When the search fails or
the search is interrupted, the /finish-node/ of the tree is set to nil.

** Tree classes
*** Class: =rrt-tree-list=					      :class:

**** Inheritance
- Parent classes:
   [[class rrt-tree-mixin][rrt-tree-mixin]]
- Precedence list:
    [[class rrt-tree-list][rrt-tree-list]], [[class rrt-tree-mixin][rrt-tree
    mixin]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

an rrt-tree implementation which uses
 a simple linear search method for nearest-search.

**** Direct Slots

# link target 2: <<nodes>>
# link target: <<slot nodes>>

***** Slot: =nodes=						       :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance

Stores the list of nodes. 

*** Class: =rrt-tree-tree=					      :class:

**** Inheritance

- Parent classes:
    [[class rrt-tree-mixin][rrt-tree-mixin]]
- Precedence list:
    [[class rrt-tree-tree][rrt-tree-tree]], [[class rrt-tree-mixin][rrt-tree
    mixin]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

An rrt-tree implementation which 
does breadth-first search in nearest-search.
The slot /nodes/ are never used. 

** Conditions
*** Class: =child-not-found=					      :class:

**** Inheritance

- Parent classes:
    [[class simple-condition][simple-condition]]
- Precedence list:
    [[class child-not-found][child-not-found]], [[class simple-condition][simple
    condition]], [[class condition][condition]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

Signaled when you try to [[disconnect]] a child node from a node that is
not its parent.

**** Direct Slots

# link target 2: <<parent>>
# link target: <<slot parent>>

***** Slot: =parent=						       :slot:
***** Slot: =child=						       :slot:

** Path and tree walking
*** Function: =result-path=					   :function:


#+BEGIN_SRC lisp
(result-path tree)
#+END_SRC

Returns a list of C-space points of the computed paths
from the root to the end.  Returns nil if the path was not found. The
list contains the root of the tree.


*** Function: =result-path-nodes=				   :function:

#+BEGIN_SRC lisp
(result-path-nodes tree)
#+END_SRC

Returns the nodes of the computed path in a list, from
the root to the end. Returns nil if the path was not found. The list
contains the root of the tree.



*** Function: =map-rrt-tree-content-recursively=		   :function:

#+BEGIN_SRC lisp
(map-rrt-tree-content-recursively node fn)
#+END_SRC

Map over the contents of RRT-TREE-NODEs of the tree and
 return each result in a nested tree 
with the same structure as the original random-tree.


*** Function: =map-rrt-tree-node-recursively=			   :function:

#+BEGIN_SRC lisp
(map-rrt-tree-node-recursively node fn)
#+END_SRC

Map over the RRT-TREE-NODEs of the tree and
 return the results in a nested cons tree 
with the same structure as that of the original random-tree.

*** Function: =mapc-rrt-tree-content-recursively=		   :function:

#+BEGIN_SRC lisp
(mapc-rrt-tree-content-recursively node fn)
#+END_SRC

Mapc over the contents of RRT-TREE-NODEs ofthe tree and returns nil.
 Only for the side effect.


*** Function: =mapc-rrt-tree-node-recursively=			   :function:

#+BEGIN_SRC lisp
(mapc-rrt-tree-node-recursively node fn)
#+END_SRC

Mapc over the RRT-TREE-NODEs of the tree and returns nil.
 Only for the side effect.


*** Function: =nnext-branch=					   :function:

#+BEGIN_SRC lisp
(nnext-branch tree)
#+END_SRC

Destructively modifies and return an RRT-TREE.  If the
/tree/ has a finish node, it finds a path from the root to
the end and then replace the root with the next node in that path.
Otherwise it choose one child of the root at random and replace the
root with it. In both cases the new root is orphanized.


** Node manipulation helper
*** Function: =rrt-node=					   :function:

#+BEGIN_SRC lisp
(rrt-node content)
#+END_SRC


Identical to =(make-instance 'rrt-tree-node :content content)=


*** Function: =adopt-children=					   :function:

#+BEGIN_SRC lisp
(adopt-children new-parent old-parent)
#+END_SRC

HELPER FUINCTION: removes the children of old-parent and
the new-parent takes all of them.


*** Function: =connect=						   :function:

#+BEGIN_SRC lisp
(connect parent child)
#+END_SRC

connect two nodes as a parent and a child.


*** Function: =disconnect=					   :function:

#+BEGIN_SRC lisp
(disconnect parent child)
#+END_SRC

disconnect a parent and its child.
signals CHILD-NOT-FOUND < SIMPLE-CONDITION.


*** Function: =neglect=						   :function:

#+BEGIN_SRC lisp
(neglect parent)
#+END_SRC

HELPER FUNCTION: disconnect all children from the
specified parent


*** Function: =orphanize=					   :function:

#+BEGIN_SRC lisp
(orphanize child)
#+END_SRC

HELPER FUNCTION: ensure a node doesn't have a parent


* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

