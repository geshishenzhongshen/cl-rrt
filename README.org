#+title: CL-RRT
#+author: Masataro Asai
#+email: guicho2.71828@gmail.com
#+LINK: hs http://www.lispworks.com/reference/HyperSpec//%s

* CL-RRT - Common Lisp implementation of RRT (Rapidily exploring Random Tree)

RRT is a fast probabilistic multidimentional path-plannning algorithm
introduced by S.M.LaValle [fn:paper]. It now has a widespread use in robotics
and now able to handle the real time systems such as automatic car
driving AI. Also, it has various extentions and optimization methods
such as:

+ MP-RRT
+ RR-belief-tree
+ RRG
+ RRT*
+ St-RRT

[fn:paper] S.M. LaValle and J.J. Kuffner. Randomized kinodynamic
planning. /The International Journal of Robotics Research/, Vol. 20,
No. 5, pp. 378â€“400, 2001.

** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ ANAPHORA  ::
    
** Installation

+ First grab the code with =git clone git@github.com:guicho271828/cl-rrt.git=
+ Put it in local-project folder
+ open slime REPL
+ =(ql:quickload :cl-rrt)= and the library will be installed along with all
  the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)
+ Univ. Tokyo -> Grad. school of Tokyo University

* API

** Core Interfaces
*** Class: =rrt-tree-mixin=					      :class:
The abstract interface mixin class of rrt-tree. User do not create
an instance of it, but rather inherit it. It has three slots and accessors with the same names:

+ root :: the root node of the tree. of type rrt-tree-node.
+ nodes :: an abstract slot which should be redefined in the inherited class.
   stores a container of the entire nodes.
+ finish-nodes :: a slot which contains the last node of the computed path.
   It is bound to nil, it means the previous search has failed to find
   a path which satisfies the goal condition.

**** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class rrt-tree-mixin][rrt-tree-mixin]], [[class standard-object][standard
    object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class rrt-tree-tree][rrt-tree-tree]], [[class rrt-tree-list][rrt-tree-list]]

*** Class: =rrt-tree-node=					      :class:

Node class of Random Tree. 

+ parent :: Parent node. 
+ children :: a list of child nodes.
+ content :: Stores C-space point data which should support a method
  [[cofiguration-space-distance]]. All holonomic and non-holonomic values
  such as position, velocity and accelaration should be stored in
  the instance in /content/.

**** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class rrt-tree-node][rrt-tree-node]], [[class standard-object][standard
    object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.

*** Standard Generic Function: =configuration-space-distance= 	   :function:
**** Syntax

#+BEGIN_SRC lisp
(configuration-space-distance point1 point2)
#+END_SRC

**** Description

This generic function should provide a method to measure the distance
between two points in C-space (configuration space). Users should
implement the desired method on its own.

*** Standard Generic Function: =nearest-node=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(nearest-node target tree)
#+END_SRC

**** Description

This generic function should implement a method
which finds the nearest node in a /tree/ to the /target/.
/target/ is an instance of holonomic point class.

*** Function: =rrt-search=					   :function:

#+BEGIN_SRC lisp
(rrt-search start-v
            random-generator new-v-generator
            edge-prohibited-p finish-p
            &key tree (tree-class 'rrt-tree-tree) (max-nodes 15)
            (max-iteration 30) run-on-node)
;; --> tree, num-nodes, iteration
#+END_SRC

RRT-search function.
let /V/ as a type variable.

+ /V/ :: a vector class which represents a point in C-space.
           (configuration-space-distance V V) should return a number.
+ (node /V/) :: an rrt-tree-node instance whose /content/ slot is V.
                holonomic and non-holonomic parameters like velocity
                and acceralation should be stored in V.

I use these expression above as a type specifier in the following
description and specification.

+ start-v :: /V/ -- A starting point of RRT searching in a C-space. It
             will be stored in the root node of the /tree/ if no
             /tree/ is specified in the *&key* arguments. 
+ random-generator :: (no args) -> /V/ random
+ new-v-generator ::  /V/ nearest, /V/ random -> /V/ new
+ edge-prohibited-p :: /V/ nearest, /V/ new -> /Bool/ result
+ finish-p :: /V/ new -> /Bool/ result

+ tree :: A tree to be used as a prototype of the search.  It is
          going to be destructively modified in the search.  If not
          specified, it internally creates an instance of
          /tree-class/.
+ tree-class :: a /Class specifier/.
+ max-nodes :: a /Fixnum/ which specify the maximum number of nodes
               in the tree. When the total number of nodes reaches
               this limit, it finish the search iteration without
               setting the /finish-node/ of /tree/.
+ max-iteration :: a /Fixnum/ which specify the maximum number of
                   iteration in /rrt-search/. When the total number
                   of iteration reaches this limit, it finish the
                   search iteration without setting the
                   /finish-node/ of /tree/.
+ run-on-node :: /V/ nearest, /V/ new -> t
		 -- a function called in the last of each iteration.

/rrt-search/ returns the result tree as its primary value.  The
secondaly value is the total number of the nodes, and third value is
the number of iteration done in the search. When the search fails or
the search is interrupted, the /finish-node/ of the tree is set to nil.

** Tree classes
*** Class: =rrt-tree-list=					      :class:

**** Inheritance
- Parent classes:
   [[class rrt-tree-mixin][rrt-tree-mixin]]
- Precedence list:
    [[class rrt-tree-list][rrt-tree-list]], [[class rrt-tree-mixin][rrt-tree
    mixin]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

an rrt-tree implementation which uses
 a simple linear search method for nearest-search.

**** Direct Slots

# link target 2: <<nodes>>
# link target: <<slot nodes>>

***** Slot: =nodes=						       :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance

Stores the list of nodes. 

*** Class: =rrt-tree-tree=					      :class:

**** Inheritance

- Parent classes:
    [[class rrt-tree-mixin][rrt-tree-mixin]]
- Precedence list:
    [[class rrt-tree-tree][rrt-tree-tree]], [[class rrt-tree-mixin][rrt-tree
    mixin]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

An rrt-tree implementation which 
does breadth-first search in nearest-search.
The slot /nodes/ are never used. 

** Conditions
*** Class: =child-not-found=					      :class:

**** Inheritance

- Parent classes:
    [[class simple-condition][simple-condition]]
- Precedence list:
    [[class child-not-found][child-not-found]], [[class simple-condition][simple
    condition]], [[class condition][condition]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.

**** Description

Signaled when you try to [[disconnect]] a child node from a node that is
not its parent.

**** Direct Slots

# link target 2: <<parent>>
# link target: <<slot parent>>

***** Slot: =parent=						       :slot:
***** Slot: =child=						       :slot:

** Path and tree walking
*** Function: =result-path=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(result-path tree)
#+END_SRC

**** Description

Returns a list of C-space points of the computed paths
from the root to the end.  Returns nil if the path was not found. The
list contains the root of the tree.



-----

# link target 2: <<result-path-nodes>>
# link target: <<function result-path-nodes>>

*** Function: =result-path-nodes=				   :function:

**** Syntax

#+BEGIN_SRC lisp
(result-path-nodes tree)
#+END_SRC

**** Description

Returns the nodes of the computed path in a list, from
the root to the end. Returns nil if the path was not found. The list
contains the root of the tree.



-----

# link target 2: <<root>>
# link target: <<function root>>

*** Function: =map-rrt-tree-content-recursively=		   :function:

**** Syntax

#+BEGIN_SRC lisp
(map-rrt-tree-content-recursively node fn)
#+END_SRC

**** Description

Map over the contents of RRT-TREE-NODEs of the tree and
 return each result in a nested tree 
with the same structure as the original random-tree.



-----

# link target 2: <<map-rrt-tree-node-recursively>>
# link target: <<function map-rrt-tree-node-recursively>>

*** Function: =map-rrt-tree-node-recursively=			   :function:

**** Syntax

#+BEGIN_SRC lisp
(map-rrt-tree-node-recursively node fn)
#+END_SRC

**** Description

Map over the RRT-TREE-NODEs of the tree and
 return the results in a nested cons tree 
with the same structure as that of the original random-tree.



-----

# link target 2: <<mapc-rrt-tree-content-recursively>>
# link target: <<function mapc-rrt-tree-content-recursively>>

*** Function: =mapc-rrt-tree-content-recursively=		   :function:

**** Syntax

#+BEGIN_SRC lisp
(mapc-rrt-tree-content-recursively node fn)
#+END_SRC

**** Description

Mapc over the contents of RRT-TREE-NODEs ofthe tree and returns nil.
 Only for the side effect.



-----

# link target 2: <<mapc-rrt-tree-node-recursively>>
# link target: <<function mapc-rrt-tree-node-recursively>>

*** Function: =mapc-rrt-tree-node-recursively=			   :function:

**** Syntax

#+BEGIN_SRC lisp
(mapc-rrt-tree-node-recursively node fn)
#+END_SRC

**** Description

Mapc over the RRT-TREE-NODEs of the tree and returns nil.
 Only for the side effect.



-----

# link target 2: <<nearest-node>>
# link target: <<function nearest-node>>

*** Function: =nnext-branch=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(nnext-branch tree)
#+END_SRC

**** Description

Destructively modifies and return an RRT-TREE.  If the
/tree/ has a finish node, it finds a path from the root to
the end and then replace the root with the next node in that path.
Otherwise it choose one child of the root at random and replace the
root with it. In both cases the new root is orphanized.



-----

# link target 2: <<nodes>>
# link target: <<function nodes>>

** Node manipulation helper
*** Function: =rrt-node=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(rrt-node content)
#+END_SRC

**** Description


Identical to =(make-instance 'rrt-tree-node :content content)=



-----

# link target 2: <<rrt-search>>
# link target: <<function rrt-search>>
*** Function: =adopt-children=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(adopt-children new-parent old-parent)
#+END_SRC

**** Description

HELPER FUINCTION: removes the children of old-parent and
the new-parent takes all of them.



-----

# link target 2: <<children>>
# link target: <<function children>>

*** Function: =connect=						   :function:

**** Syntax

#+BEGIN_SRC lisp
(connect parent child)
#+END_SRC

**** Description

connect two nodes as a parent and a child.



-----

# link target 2: <<content>>
# link target: <<function content>>

*** Function: =disconnect=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(disconnect parent child)
#+END_SRC

**** Description

disconnect a parent and its child.
signals CHILD-NOT-FOUND < SIMPLE-CONDITION.



-----

# link target 2: <<finish-node>>
# link target: <<function finish-node>>

*** Function: =neglect=						   :function:

**** Syntax

#+BEGIN_SRC lisp
(neglect parent)
#+END_SRC

**** Description

HELPER FUNCTION: disconnect all children from the
specified parent



-----

# link target 2: <<nnext-branch>>
# link target: <<function nnext-branch>>

*** Function: =orphanize=					   :function:

**** Syntax

#+BEGIN_SRC lisp
(orphanize child)
#+END_SRC

**** Description

HELPER FUNCTION: ensure a node doesn't have a parent



-----

# link target 2: <<parent>>
# link target: <<function parent>>

* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

